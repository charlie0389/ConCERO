
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>from_cero &#8212; ConCERO 0.1 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for from_cero</h1><div class="highlight"><pre>
<span></span><span class="c1">#      ConCERO - a program to automate data format conversion and the execution of economic modelling software.</span>
<span class="c1">#      Copyright (C) 2018  CSIRO Energy Business Unit</span>
<span class="c1">#</span>
<span class="c1">#     This program is free software: you can redistribute it and/or modify</span>
<span class="c1">#     it under the terms of the GNU General Public License as published by</span>
<span class="c1">#     the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">#     (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1">#     This program is distributed in the hope that it will be useful,</span>
<span class="c1">#     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1">#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1">#     GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1">#     You should have received a copy of the GNU General Public License</span>
<span class="c1">#     along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Output-Independent Instructions</span>
<span class="sd">-------------------------------</span>

<span class="sd">Setting up a FromCERO configuration file</span>
<span class="sd">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span>

<span class="sd">Like all other configuration files for this program, the configuration file must be in YAML format. The highest \</span>
<span class="sd">hierarchical level (i.e. with the least/no indentation) is referred to as a *FromCERO object*).</span>
<span class="sd">It is **necessary** (for the configuration to output anything meaningful) to define the option:</span>

<span class="sd">    * ``procedures: (list[dict|str])``, where ``procedures`` is a list of one or more *procedure* objects. \</span>
<span class="sd">    :ref:`procedure objects` are explained below .</span>

<span class="sd">Procedures define the mutation(s) and, if desired, the export of the mutated data to a file. If a procedure does not specify an export file then ConCERO will, by default, output the procedure to ``output.csv`` in the current working directory. The default output file can be overwridden by specifying the ``file`` option of the FromCERO object.</span>

<span class="sd">It is *recommended* that the following option be specified:</span>

<span class="sd">    * ``file: (str)`` - Names the file for which all procedure objects are exported into. Procedure objects will export \</span>
<span class="sd">     into this file unless a procedure-object-specific ``file`` has been defined. The extension of ``file`` determines \</span>
<span class="sd">     the exported file type. Supported file types are:</span>

<span class="sd">        * Numpy arrays - ``npy``</span>
<span class="sd">        * GAMS Data eXchange format - ``gdx`` (temporarily unsupported)</span>
<span class="sd">        * HAR files - ``har``</span>
<span class="sd">        * Shock files - ``shk``</span>
<span class="sd">        * Portable Network Graphics format - ``png``</span>
<span class="sd">        * Portable Document Format - ``pdf``</span>
<span class="sd">        * PostScript - ``ps``</span>
<span class="sd">        * Encapsulated PostScript - ``eps``</span>
<span class="sd">        * Scalable Vector Graphics - ``svg``</span>

<span class="sd">Other options include:</span>

<span class="sd">    * ``sets: (dict: str -&gt; List[str])`` - sets is a dictionary mapping ``str`` to a ``list`` of  ``str``. ``sets`` provides \</span>
<span class="sd">    an easy and convenient way to select groups of CERO identifiers (see :ref:`cero_ids`), as opposed to simply listing \</span>
<span class="sd">    all the identifiers that are of interest for output. More detail about sets is provided below in the section :ref:`sets`.</span>
<span class="sd">    * ``map: (dict: str -&gt; str)`` - key-value pairs that maps the &quot;old&quot; identifier to a &quot;new&quot; identifier.</span>
<span class="sd">    * ``ref_dir: (str)`` where ``ref_dir`` is a file path relative to the current working directory. By default, all \</span>
<span class="sd">    file names are interpreted as being relative to the configuration file. Providing this option overrides the default.</span>
<span class="sd">    * ``lstrip: (str)`` where ``str``, if provided, strips the left-most substring from all identifiers that make up the input. If the string does not match the start of the identifier (if the identifier is a `str`), or the first field of the identifier (if the identifier is a `tuple`), then a `ValueError` is raised. This option is designed to correspond to CEROs generated using ToCERO with the ``auto_prepend`` option provided.</span>
<span class="sd">    * ``libfuncs: (str|list[str])`` - paths relative to ``ref_dir`` of python files containing functions to use as operation functions. Note that the ``.py`` filename extension must be included. The structure of a libfuncs file is discussed below in :ref:`libfuncs_files`.</span>

<span class="sd">Note that, in general, properties at a lower level (i.e. more indentation) &#39;inherit&#39; from a higher level.</span>

<span class="sd">So, an example configuration, in YAML format, is:</span>

<span class="sd">.. code-block:: yaml</span>

<span class="sd">    file: a_csv_file.csv</span>
<span class="sd">    procedures:</span>
<span class="sd">        - &lt;Procedure Object A&gt;</span>
<span class="sd">        - &lt;Procedure Object B&gt;</span>
<span class="sd">        - &lt;Procedure Object C&gt;</span>
<span class="sd">        - &lt;etc.&gt;</span>

<span class="sd">Examples of complete configuration files can be found in the ``tests/data`` subdirectory of the ConCERO install path.</span>

<span class="sd">.. _procedure objects:</span>

<span class="sd">Procedure Objects</span>
<span class="sd">#################</span>

<span class="sd">Conceptually, procedure objects provide the instructions to select data from a CERO, mutate that data (if necessary), \</span>
<span class="sd">and then either, (a): output this data into a file, or (b): return outputs for later export into a global file \</span>
<span class="sd">(specified by the ``file`` option in the outputs object). Any mutations that are applied to a procedure object&#39;s \</span>
<span class="sd">``inputs`` are isolated from any other procedure object and the CERO itself - i.e. each procedure can be \</span>
<span class="sd">considered a &#39;silo&#39; separate from others.</span>

<span class="sd">A *procedure object* can be either a ``str`` or a ``dict``. The ``dict`` form is the more general form - if a \</span>
<span class="sd">procedure object is provided as the (``str``) ``ser_obj``, it is immediately converted to the equivalent form \</span>
<span class="sd">``{&#39;name&#39;: ser_obj}``. The complete list of options is:</span>

<span class="sd">    * ``name: (str)`` - the name given to the procedure. Will, by default, given the name ``Unnamed_proc``.</span>
<span class="sd">    * ``file: (str)`` - if provided, the output from this procedure object, and only this procedure object, will \</span>
<span class="sd">    be exported to ``file``.</span>
<span class="sd">    * ``inputs: list(str|list(str))`` - is a list of identifiers corresponding to identifiers in the CERO. \</span>
<span class="sd">    If an item of the list is a string with one or more commas, or is itself a list, then the item will be \</span>
<span class="sd">    interpreted as a tuple-form identifier. See :ref:`cero_ids`.</span>
<span class="sd">    * ``outputs: list(str|list(str))`` - a list of identifiers that are to be exported to the file. If outputs \</span>
<span class="sd">    are not specified, then ConCERO will export all *updated* inputs after all operations are performed. Read \</span>
<span class="sd">    :ref:`output_process_flow` to understand what is meant by *updated* inputs. If it is desirable that none of the data \</span>
<span class="sd">    series be exported to a file in a conventional manner, which is the case if - for example - plotting output, \</span>
<span class="sd">    then specify ``outputs``, but leave the corresponding value blank to indicate a value of ``None``. \</span>
<span class="sd">    If an item of the list is a string with one or more commas, or is itself a list, then the item will be \</span>
<span class="sd">    interpreted as a tuple-form identifier. See :ref:`cero_ids`.</span>
<span class="sd">    * ``operations: list[operations objects]`` - to mutate the ``inputs`` into a desirable form for export, \</span>
<span class="sd">    operations must be applied to mutate the data. ``operations`` is a list of *operations objects*, which \</span>
<span class="sd">    modify the data in a sequential manner. See :ref:`operations_objects` for more information.</span>
<span class="sd">    * ``libfuncs: (str|list[str])`` - Identical in meaning to the equivalent ``FromCERO`` object option. Is inherited from a ``FromCERO`` object if not given.</span>

<span class="sd">Below is a shell showing the two different procedure object types:</span>

<span class="sd">.. code-block:: yaml</span>

<span class="sd">    procedures:</span>
<span class="sd">        - name: (str)</span>
<span class="sd">          inputs: (list[str])</span>
<span class="sd">          operations: (list[operation])</span>
<span class="sd">          output_file: (str)</span>
<span class="sd">        - (str)</span>

<span class="sd">The 1st procedure object is in dictionary form, and the 2nd is in string form.</span>

<span class="sd">Inheritance paths</span>
<span class="sd">#################</span>

<span class="sd">Below is an outline of how options are inherited:</span>

<span class="sd">    * ``inputs`` - If inputs is undefined, then ``inputs`` is the entire CERO (whatever that may be at runtime).</span>
<span class="sd">    * ``outputs`` - If outputs is undefined or ``True``, then all ``inputs`` are ``outputs``. If ``outputs`` is `False` or `None`, then there are no ``outputs``. A `list` or `str` can be provided to select specific ``outputs``.</span>

<span class="sd">.. _operations_objects:</span>

<span class="sd">Operations Objects</span>
<span class="sd">##################</span>

<span class="sd">An *operation* refers to the process of applying a function to some inputs to return an output(s). Unlike separate \</span>
<span class="sd">procedures, operations (within the same procedure object) can *not* be considered to operate in a &#39;silo-ed&#39; manner, and \</span>
<span class="sd">therefore the order of ``operations`` is significant. Each item of the list ``operations`` must be an \</span>
<span class="sd">*operation object* - that is, a ``dict``, which may contain the options:</span>

<span class="sd">    * ``func: (str)`` - ``func`` is the name of a function present in a ``libfuncs`` library that is applied to \</span>
<span class="sd">    ``arrays`` (see below). The functions available \</span>
<span class="sd">    can be easily expanded by:</span>
<span class="sd">        #. Correctly identifying the class of the new function - see :ref:`func_classes`.</span>
<span class="sd">        #. Adding the function to a python source code file, *with the associated function decorator* (as explained in :ref:`func_classes`), and providing that file to ConCERO with the ``libfuncs`` *procedure* option. The system ``libfuncs.py`` will be searched after any referenced files.</span>
<span class="sd">    * ``arrays: list(str|list(str))`` - ``arrays`` defines which of the ``inputs`` that ``func`` will manipulate. If ``arrays`` is not provided, ``arrays`` defaults to all procedure object ``inputs``.  Note that any manipulation applied to ``arrays`` will be in effect for all subsequent ``operations``.</span>
<span class="sd">    * ``rename: (list|dict)`` - providing this option as a list renames ``arrays`` after the application of ``func`` (if provided). If ``rename`` is provided as a `list`, then the list is parsed as identifiers (see :ref:`cero_ids`) and must be the same length as ``arrays``. If provided as a `dict`, only those ``arrays`` matching keys in the dict are renamed to the corresponding value. Regardless of the form of ``rename`` (i.e. `list` or `dict`), references to ``sets`` can be made. In the specific case that there is one and only one ``arrays``, then ``rename`` can be provided as a `str`. If `rename` is provided and the new identifier values are not already in ``arrays``, then ``rename`` expands ``arrays`` to include the new identifers (and the data series corresponding to the original identifiers are left untouched). By using this behaviour, ``rename`` can be used to apply ``func`` to specific ``arrays`` without altering the original ``arrays``.</span>
<span class="sd">    * ``start_year: (int)`` - this option constrains the dataset to years after and **including** ``start_year``. This \</span>
<span class="sd">    option may be useful to avoid attempting to apply ``func`` to missing data.</span>
<span class="sd">    * ``end_year: (int)`` - this option constrains the dataset to years before and **including** ``end_year``. This \</span>
<span class="sd">    option may be useful to avoid attempting to apply ``func`` to missing data.</span>

<span class="sd">Any additional options are passed to ``func`` as keyword arguments.</span>

<span class="sd">.. _sets:</span>

<span class="sd">Sets</span>
<span class="sd">####</span>

<span class="sd">The ``sets`` option must have the following form:</span>

<span class="sd">``sets: dict[str -&gt; list(str)]``</span>

<span class="sd">The ``sets`` option provides a powerful way to list many identifiers with a small amount of references. An example configuration of sets is:</span>

<span class="sd">.. code-block:: yaml</span>

<span class="sd">    sets:</span>
<span class="sd">        ASET:</span>
<span class="sd">            - a</span>
<span class="sd">            - b</span>
<span class="sd">            - c</span>

<span class="sd">A user can then specify all the elements of the set (for ``inputs``, ``arrays`` and ``outputs``) by referencing \</span>
<span class="sd">the set. For example:</span>

<span class="sd">.. code-block:: yaml</span>

<span class="sd">    sets:</span>
<span class="sd">        ASET:</span>
<span class="sd">            - a</span>
<span class="sd">            - b</span>
<span class="sd">            - c</span>
<span class="sd">            - d</span>
<span class="sd">            - e</span>
<span class="sd">    procedures:</span>
<span class="sd">        - name: a_procedure</span>
<span class="sd">          inputs: ASET</span>
<span class="sd">          operations:</span>
<span class="sd">            - func: a_func</span>
<span class="sd">        - name: b_procedure</span>
<span class="sd">          inputs: ASET</span>
<span class="sd">          operations:</span>
<span class="sd">            - func: b_func</span>

<span class="sd">Which is equivalent to the more verbose:</span>

<span class="sd">.. code-block:: yaml</span>

<span class="sd">    procedures:</span>
<span class="sd">        - name: a_procedure</span>
<span class="sd">          inputs:</span>
<span class="sd">            - a</span>
<span class="sd">            - b</span>
<span class="sd">            - c</span>
<span class="sd">            - d</span>
<span class="sd">            - e</span>
<span class="sd">          operations:</span>
<span class="sd">            - func: a_func</span>
<span class="sd">        - name: b_procedure</span>
<span class="sd">          inputs:</span>
<span class="sd">            - a</span>
<span class="sd">            - b</span>
<span class="sd">            - c</span>
<span class="sd">            - d</span>
<span class="sd">            - e</span>
<span class="sd">          operations:</span>
<span class="sd">            - func: b_func</span>

<span class="sd">Specifying ``sets`` is even more powerful when using them in the context of tuple-identifiers. For example, \</span>
<span class="sd">consider that these (100*100 = 10,000) identifiers were in the CERO (in python list form):</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    [(&#39;1&#39;, &#39;1&#39;), (&#39;1&#39;, &#39;2&#39;), (&#39;1&#39;, &#39;3&#39;), ..., (&#39;1&#39;, &#39;100&#39;), (&#39;2&#39;, &#39;1&#39;), (&#39;2&#39;, &#39;2&#39;), ..., (&#39;2&#39;, &#39;100&#39;),</span>
<span class="sd">     (&#39;3&#39;, &#39;1&#39;), ..., (&#39;3&#39;, &#39;100&#39;), ..., (&#39;100&#39;, &#39;100&#39;)]</span>

<span class="sd">Rather than listing all 10,000 identifiers, a user can create a set:</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    sets = {&#39;century&#39;: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, ..., &#39;100&#39;]}</span>

<span class="sd">and select all 10,000 identifiers by referencing the set twice with a comma inbetween - e.g. in YAML:</span>

<span class="sd">.. code-block:: yaml</span>

<span class="sd">    inputs:</span>
<span class="sd">        - century,century</span>

<span class="sd">Note that the selection takes place by using the cartesian product operation, and it is necessary that the \</span>
<span class="sd">cartesian product be convex.</span>

<span class="sd">.. _libfuncs_files:</span>

<span class="sd">Libfuncs Files</span>
<span class="sd">##############</span>

<span class="sd">A libfuncs file is a standard python source file. However, to use the definitions as operations in ConCERO, it is necessary to wrap the functions with specialised wrappers. Therefore, an example python source code file that provides ConCERO-compatible operations is:</span>

<span class="sd">.. code-block:: python</span>

<span class="sd">    from concero.libfuncs_wrappers import recursive_op</span>

<span class="sd">    @recursive_op</span>
<span class="sd">    def double_values(x):</span>
<span class="sd">        return 2*x</span>

<span class="sd">Where the ``double_values`` function will simply double the value of all input series. Note that ``series_op`` and ``dataframe_op`` are also wrappers to encapsulate functions to ensure they are ConCERO-compatible. For more information on how to use the wrappers, please consult :ref:`func_classes` .</span>

<span class="sd">.. _output_process_flow:</span>

<span class="sd">Description of the output process-flow</span>
<span class="sd">--------------------------------------</span>

<span class="sd">Each procedure object corresponds to the output of an object into a file. Every procedure takes inputs (from a CERO), mutates this inputs in some way (or not  and then outputs some, if not all, of the mutated inputs into a file. More specifically, in converting a CERO \</span>
<span class="sd">to an output file, the general process flow is:</span>

<span class="sd">    #. From the given CERO, identify using ``inputs`` the relevant data series by their identifier.</span>
<span class="sd">    #. Copy those ``inputs`` to avoid disturbing/mutating the original CERO.</span>
<span class="sd">    #. From the copied inputs, perform a sequence of operations where, for each operation:</span>
<span class="sd">        #. All of the ``inputs``, or a subset of ``inputs`` is selected (that is, the ``arrays``).</span>
<span class="sd">        #. A function mutates the ``arrays``.</span>
<span class="sd">        #. If given, ``arrays`` are ``rename`` d.</span>
<span class="sd">        #. The copied inputs get updated with the mutated ``arrays``. For values of ``arrays`` that match ``inputs``, those ``inputs`` are overwritten. Otherwise (in the event ``arrays`` have been ``rename`` &#39;d) they are added to ``inputs``.</span>
<span class="sd">    #. Export ``outputs`` to either:</span>
<span class="sd">        #. ``file``, if ``file`` is specified the procedure object, or</span>
<span class="sd">        #. ``file`` as defined in the FromCERO object, *if specified*, or</span>
<span class="sd">        #. ``output.csv`` if ``file`` is unspecified in either the procedure or FromCERO objects.</span>


<span class="sd">FromCERO Technical Specification</span>
<span class="sd">--------------------------------</span>

<span class="sd">.. autoclass:: FromCERO</span>
<span class="sd">    :members:</span>

<span class="sd">Created on Jan 22 08:44:08 2018</span>

<span class="sd">.. sectionauthor:: Lyle Collins &lt;Lyle.Collins@csiro.au&gt;</span>
<span class="sd">.. codeauthor:: Lyle Collins &lt;Lyle.Collins@csiro.au&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">concero.conf</span>
<span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">concero</span><span class="o">.</span><span class="n">conf</span><span class="p">,</span> <span class="s2">&quot;gdxpds_installed&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">gdxpds</span> <span class="c1">#: Warning given if not imported before pandas</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">getpass</span>
<span class="kn">import</span> <span class="nn">importlib.util</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">ModuleType</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">concero.cero</span> <span class="k">import</span> <span class="n">CERO</span>
<span class="kn">import</span> <span class="nn">concero.libfuncs</span> <span class="k">as</span> <span class="nn">libfuncs</span>
<span class="kn">from</span> <span class="nn">concero.format_convert_tools</span> <span class="k">import</span> <span class="n">read_yaml</span>
<span class="kn">from</span> <span class="nn">concero._identifier</span> <span class="k">import</span> <span class="n">_Identifier</span>
<span class="kn">import</span> <span class="nn">concero.libfuncs_wrappers</span> <span class="k">as</span> <span class="nn">libfuncs_wrappers</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>

<div class="viewcode-block" id="FromCERO"><a class="viewcode-back" href="../reference.html#from_cero.FromCERO">[docs]</a><span class="k">class</span> <span class="nc">FromCERO</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
    <span class="n">sup_output_types</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;csv&#39;</span><span class="p">,</span> <span class="s1">&#39;xlsx&#39;</span><span class="p">,</span> <span class="s1">&#39;excel&#39;</span><span class="p">,</span> <span class="s1">&#39;npy&#39;</span><span class="p">,</span> <span class="s1">&#39;png&#39;</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="s1">&#39;svg&#39;</span><span class="p">}</span>
    <span class="n">_logger</span> <span class="o">=</span> <span class="n">concero</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">setup_logger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">_Procedure</span><span class="p">(</span><span class="nb">dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;_Procedure object class.&quot;&quot;&quot;</span>

        <span class="n">_sup_procedure_output_types</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;csv&#39;</span><span class="p">,</span> <span class="s1">&#39;xlsx&#39;</span><span class="p">,</span> <span class="s1">&#39;excel&#39;</span><span class="p">,</span> <span class="s1">&#39;npy&#39;</span><span class="p">,</span> <span class="s1">&#39;har&#39;</span><span class="p">,</span> <span class="s1">&#39;shk&#39;</span><span class="p">,</span> <span class="s1">&#39;png&#39;</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="s1">&#39;svg&#39;</span><span class="p">}</span> <span class="c1"># &quot;gdx&quot;</span>

        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proc_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="s1">&#39;FromCERO&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

            <span class="n">proc</span> <span class="o">=</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_Procedure</span><span class="o">.</span><span class="n">load_config</span><span class="p">(</span><span class="n">proc_dict</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">)</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_Procedure</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


        <span class="nd">@staticmethod</span>
        <span class="k">def</span> <span class="nf">load_config</span><span class="p">(</span><span class="n">proc_dict</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="s1">&#39;FromCERO&#39;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>

            <span class="c1"># Add default options here</span>
            <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Unnamed_proc&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;operations&quot;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s2">&quot;inputs&quot;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="s2">&quot;ref_dir&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;sets&quot;</span><span class="p">:</span> <span class="p">{},</span>
                        <span class="s2">&quot;map&quot;</span><span class="p">:</span> <span class="p">{},</span>
                        <span class="s2">&quot;libfuncs&quot;</span><span class="p">:</span> <span class="p">[],</span>
                        <span class="p">}</span>

            <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">parent</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="n">defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
            <span class="n">defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">proc_dict</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">defaults</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
            <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">defaults</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;file&quot;</span><span class="p">):</span>
                <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">],</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">]))</span>

            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">defaults</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">)),</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">]]</span>

            <span class="n">lf_files</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">lf</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">lf</span><span class="p">),</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">lf</span> <span class="ow">in</span> <span class="n">proc_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">,</span> <span class="p">[]):</span>
                    <span class="n">lf</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">],</span> <span class="n">lf</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">lf</span><span class="p">),</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">lf</span><span class="p">),</span> <span class="n">ModuleType</span><span class="p">):</span>
                    <span class="n">lf</span> <span class="o">=</span> <span class="n">lf</span><span class="o">.</span><span class="vm">__file__</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;libfuncs&#39; must be provided as a list of strings and/or modules (not </span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">lf</span><span class="p">))</span>

                <span class="n">lf_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lf</span><span class="p">)</span>

            <span class="c1"># Ensure system libfuncs is on search path...</span>
            <span class="n">system_libfuncs</span> <span class="o">=</span> <span class="n">concero</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">find_file</span><span class="p">(</span><span class="s2">&quot;libfuncs.py&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">system_libfuncs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lf_files</span><span class="p">:</span>
                <span class="n">lf_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">system_libfuncs</span><span class="p">)</span>
                <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">system_libfuncs</span><span class="p">)</span>

            <span class="c1"># Load all libfuncs modules</span>
            <span class="n">mods</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">lf</span><span class="p">,</span> <span class="n">mod</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lf_files</span><span class="p">,</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">])):</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">mod</span><span class="p">),</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">spec</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">spec_from_file_location</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">lf</span><span class="p">),</span> <span class="n">lf</span><span class="p">)</span>
                    <span class="n">mod</span> <span class="o">=</span> <span class="n">importlib</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">module_from_spec</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
                    <span class="n">spec</span><span class="o">.</span><span class="n">loader</span><span class="o">.</span><span class="n">exec_module</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
                <span class="n">mods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>
            <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mods</span>

            <span class="c1"># Load sets</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">],</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
                    <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_yaml</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>

                <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_load_set</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]]</span>

            <span class="c1"># Determine identifiers for all inputs</span>
            <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_Identifier</span><span class="o">.</span><span class="n">get_all_idents</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">],</span> <span class="n">sets</span><span class="o">=</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">])</span>

            <span class="k">if</span> <span class="s2">&quot;lstrip&quot;</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span>
                <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">_Identifier</span><span class="o">.</span><span class="n">lstrip_identifier</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;lstrip&quot;</span><span class="p">],</span> <span class="n">inp</span><span class="p">)</span> <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]]</span>

            <span class="k">if</span> <span class="s2">&quot;outputs&quot;</span> <span class="ow">in</span> <span class="n">defaults</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">]]</span>

                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">]),</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_Identifier</span><span class="o">.</span><span class="n">get_all_idents</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">],</span> <span class="n">sets</span><span class="o">=</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">defaults</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;outputs&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                    <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">elif</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;outputs&#39; must be provided as a list, True or None.&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">defaults</span>


        <span class="k">def</span> <span class="nf">_set_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cero</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Copies each data series in ``cero`` indexed by the items in ``inp_list`` to an ``OrderedDict``. This \</span>
<span class="sd">                    ensures that ``operations`` do not alter ``cero``.</span>
<span class="sd">                    &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
                <span class="c1"># Input is entire CERO unless otherwise specified</span>
                <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cero</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># Check values in dataframe - check is necessary because KeyError is not thrown if some values are in index (pandas version 0.22).</span>
            <span class="n">invalid_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cero</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">cero</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">cero</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]]])</span> <span class="c1"># Reduce data frame to necessary data and copy</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">invalid_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cero</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Inputs </span><span class="si">%s</span><span class="s2"> do not exist. The most likely reason is that the configuration file is &quot;</span> <span class="o">+</span>
                       <span class="s2">&quot;incorrectly specified, or lacks specification. If debugging level has been set to &quot;</span> <span class="o">+</span>
                       <span class="s2">&quot;&#39;DEBUG&#39;, then the input list is in the log file - note that this list may be &quot;</span> <span class="o">+</span>
                       <span class="s2">&quot;extraordinarily long. Common causes of this problem include: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span>
                       <span class="s2">&quot; 1. Set definition in configuration file includes elements that do not exist in the CERO.</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span>
                       <span class="s2">&quot; 2. Mis-spellings of identifiers in the configuration file (which includes names of sets for &#39;inputs&#39; or &#39;arrays&#39;).</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span>
                       <span class="s2">&quot; 3. Incorrect ordering of sets in the identifier.&quot;</span>
                       <span class="p">)</span> <span class="o">%</span> <span class="n">invalid_inputs</span>
                <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">))</span>

            <span class="n">map_dict</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">map_op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;map&quot;</span><span class="p">,</span> <span class="p">[]):</span>

                <span class="n">idx</span> <span class="o">=</span> <span class="n">map_op</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;idx&quot;</span><span class="p">)</span>
                <span class="n">orig_s</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">map_op</span><span class="p">[</span><span class="s2">&quot;orig&quot;</span><span class="p">]]</span>
                <span class="n">ns</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">map_op</span><span class="p">[</span><span class="s2">&quot;new&quot;</span><span class="p">]]</span>

                <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>

                    <span class="n">new_val</span> <span class="o">=</span> <span class="n">val</span>

                    <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="ow">in</span> <span class="n">orig_s</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
                        <span class="n">new_val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[:</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">ns</span><span class="p">[</span><span class="n">orig_s</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">idx</span><span class="p">])],)</span> <span class="o">+</span> <span class="n">val</span><span class="p">[</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="k">elif</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">orig_s</span><span class="p">:</span>
                        <span class="n">new_val</span> <span class="o">=</span> <span class="n">ns</span><span class="p">[</span><span class="n">orig_s</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">val</span><span class="p">)]</span>

                    <span class="n">map_dict</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">val</span><span class="p">:</span> <span class="n">new_val</span><span class="p">})</span>
                <span class="n">CERO</span><span class="o">.</span><span class="n">rename_index_values</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">map_dict</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">exec_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cero</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            :param cero: The cero (``pandas.DataFrame``) object upon which to execute the operations. No modifications will be applied to the original cero (i.e. all modifications are applied to a copy of ``cero``).</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_set_inputs</span><span class="p">(</span><span class="n">cero</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;operations&quot;</span><span class="p">]:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_exec_op</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">CERO</span><span class="o">.</span><span class="n">combine_ceros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="n">ret</span><span class="p">],</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;outputs&quot;</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># The result of this procedures operations is to be explicitly ignored, may be useful when objective is simply to plot data</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;outputs&quot;</span><span class="p">,</span> <span class="p">[])</span> <span class="o">==</span> <span class="p">[])</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;outputs&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
                    <span class="c1"># Get all rows if none specified</span>
                    <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="n">out_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;outputs&quot;</span><span class="p">]]]</span>

            <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">out_df</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">)</span>

            <span class="k">if</span> <span class="s2">&quot;file&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="c1"># If file is specified, all &#39;outputs&#39; from this procedure go to its own file</span>
                <span class="n">output_type</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">])[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">FromCERO</span><span class="o">.</span><span class="n">dataframe_out</span><span class="p">(</span><span class="n">out_df</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">],</span> <span class="n">output_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;output_kwargs&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># procedure output name is that provided</span>
                <span class="k">return</span> <span class="p">{</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]:</span> <span class="n">out_df</span><span class="p">}</span>

        <span class="k">def</span> <span class="nf">_exec_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>

            <span class="c1"># Apply operation to procedure</span>
            <span class="n">func_name</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;func&#39;</span><span class="p">,</span> <span class="s2">&quot;noop&quot;</span><span class="p">)</span> <span class="c1"># Perform noop (no-operation) if no func provided.</span>
            <span class="n">op_args</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;args&#39;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">rename</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;rename&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="n">arrays</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="s2">&quot;arrays&quot;</span> <span class="ow">in</span> <span class="n">op</span><span class="p">:</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;arrays&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">arrays</span><span class="p">),</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrays</span><span class="p">]</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="n">_Identifier</span><span class="o">.</span><span class="n">get_all_idents</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">sets</span><span class="o">=</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">mod</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">func_name</span><span class="p">):</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">func_name</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Invalid function name provided - </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">. Function does not exist in any of the modules </span><span class="si">%s</span><span class="s1">. It may be necessary to create a python module with the necessary functions and provide this file with the </span><span class="se">\&#39;</span><span class="s1">libfuncs</span><span class="se">\&#39;</span><span class="s1"> option.&#39;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">]))</span>
                <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Function call: </span><span class="si">%s</span><span class="s2">(*arrays, **op)&quot;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="o">*</span><span class="n">op_args</span><span class="p">,</span> <span class="n">locs</span><span class="o">=</span><span class="n">arrays</span><span class="p">,</span> <span class="o">**</span><span class="n">op</span><span class="p">)</span>
            <span class="n">op</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span>  <span class="c1"># For cleanliness of presentation</span>

            <span class="k">if</span> <span class="n">rename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">libfuncs</span><span class="p">,</span> <span class="s2">&quot;noop&quot;</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">inputs</span><span class="p">,</span> <span class="o">*</span><span class="n">op_args</span><span class="p">,</span> <span class="n">locs</span><span class="o">=</span><span class="n">arrays</span><span class="p">,</span> <span class="o">**</span><span class="n">op</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rename</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">rename</span> <span class="o">=</span> <span class="p">{</span><span class="n">ret</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">rename</span><span class="p">}</span> <span class="c1"># Rename the first index by default</span>

                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">rename</span><span class="p">),</span> <span class="nb">list</span><span class="p">):</span>
                    <span class="c1"># Build mapping dictionary</span>
                    <span class="n">rename</span> <span class="o">=</span> <span class="n">_Identifier</span><span class="o">.</span><span class="n">get_mapping_dict</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">rename</span><span class="p">,</span> <span class="n">sets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sets&quot;</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">rename</span><span class="p">),</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">rename</span> <span class="o">=</span> <span class="n">_Identifier</span><span class="o">.</span><span class="n">get_one_to_one_mapping</span><span class="p">(</span><span class="n">rename</span><span class="p">,</span> <span class="n">sets</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sets&quot;</span><span class="p">))</span>

                <span class="c1"># At this point, rename should be one-to-one mapping dict</span>

                <span class="n">renamed</span> <span class="o">=</span> <span class="n">CERO</span><span class="o">.</span><span class="n">rename_index_values</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">rename</span><span class="o">.</span><span class="n">keys</span><span class="p">())],</span> <span class="n">rename</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">renamed</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">rename</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>  <span class="c1"># Restrict renamed to only the rows that have been specified</span>

                <span class="c1"># Note that ret will be restricted to only those values that have been renamed.</span>

            <span class="k">return</span> <span class="n">ret</span>

        <span class="k">def</span> <span class="nf">_check_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">operation</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;operations&quot;</span><span class="p">]:</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">operation</span><span class="p">),</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1"> is not a valid operation type. Operations must be of dict type, not </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">operation</span><span class="p">,</span>
                                                                                                              <span class="nb">type</span><span class="p">(</span><span class="n">operation</span><span class="p">))</span>
                    <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="s2">&quot;func&quot;</span> <span class="ow">in</span> <span class="n">operation</span><span class="p">:</span>

                    <span class="k">for</span> <span class="n">mod</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="n">operation</span><span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">]):</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Invalid function name provided - </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s1">. Function does not exist in any of the modules </span><span class="si">%s</span><span class="s1">. It may be necessary to create a python module with the necessary functions and provide this file with the </span><span class="se">\&#39;</span><span class="s1">libfuncs</span><span class="se">\&#39;</span><span class="s1"> option.&#39;</span> <span class="o">%</span>
                                    <span class="p">(</span><span class="n">operation</span><span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">]))</span>
                        <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                        <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">proc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Invalid procedure object - no &#39;name&#39; given.&quot;</span>
                <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">proc</span><span class="p">[</span><span class="s2">&quot;operations&quot;</span><span class="p">]),</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;operations&#39; for procedure &#39;</span><span class="si">%s</span><span class="s2">&#39; must be of list format.&quot;</span> <span class="o">%</span> <span class="n">proc</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;operations&quot;</span><span class="p">,</span> <span class="p">[])</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s2">&quot;libfuncs&quot;</span> <span class="ow">in</span> <span class="n">proc</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;If &#39;operations&#39; are defined, then so must be &#39;libfuncs&#39; (for process &#39;</span><span class="si">%s</span><span class="s2">&#39;).&quot;</span> <span class="o">%</span> <span class="n">proc</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
                <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">proc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">,</span> <span class="p">[])),</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;libfuncs&#39; for procedure &#39;</span><span class="si">%s</span><span class="s2">&#39; must be of str or list format.&quot;</span> <span class="o">%</span> <span class="n">proc</span><span class="p">[</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">]</span>
                <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_Procedure</span><span class="o">.</span><span class="n">_check_ops</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="n">raise_exception</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">proc</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">):</span>
                <span class="n">file_type</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">proc</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">])[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># get file extension without full stop</span>

                <span class="k">if</span> <span class="n">file_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_Procedure</span><span class="o">.</span><span class="n">_sup_procedure_output_types</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Output type &#39;</span><span class="si">%s</span><span class="s2">&#39; not supported. Supported types are: </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">file_type</span><span class="p">,</span>
                                                                                        <span class="n">FromCERO</span><span class="o">.</span><span class="n">_Procedure</span><span class="o">.</span><span class="n">_sup_procedure_output_types</span><span class="p">)</span>
                    <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_check_permissions</span><span class="p">(</span><span class="n">proc</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">],</span> <span class="n">raise_exception</span><span class="o">=</span><span class="n">raise_exception</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="kc">True</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span> <span class="nf">run_checks</span><span class="p">(</span><span class="n">proc</span><span class="p">,</span> <span class="n">cero</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Checks that the _Procedure ``proc`` is valid and can be executed by the current user.</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="n">cero_index</span> <span class="o">=</span> <span class="n">cero</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">invalid_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">proc</span><span class="p">[</span><span class="s2">&quot;inputs&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cero_index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">invalid_inputs</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Inputs </span><span class="si">%s</span><span class="s2"> are not valid.&quot;</span> <span class="o">%</span> <span class="n">invalid_inputs</span>
                <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_Procedure</span><span class="o">.</span><span class="n">InvalidInputs</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">def</span> <span class="nf">get_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span> <span class="nf">from_obj</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="c1"># Code to convert procedure to dict type (the superset of supported types)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="n">obj</span><span class="p">}</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="nb">dict</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Object provided can not be converted to a procedure. Objects provided must be a dict, or a subclass of.&quot;</span>
                <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_Procedure</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">proc</span>

        <span class="k">def</span> <span class="nf">get_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">],</span> <span class="n">filename</span><span class="p">)</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;get_filepath() returns: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ret</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="k">class</span> <span class="nc">InvalidInputs</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conf</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Any additional arguments and keyword arguments are passed to the superclass at initialisation (i.e. the `dict` class).</span>

<span class="sd">        :arg &quot;Union[str,dict]&quot; conf: A dictionary containing the configuration. If a `str` is provided, it is interpreted as a file (in YAML format) containing a configuration dictionary (relative to the current working directory).</span>
<span class="sd">        :arg dict parent: If provided, the created object will inherit from ``parent`` (a `dict`).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_conf</span> <span class="o">=</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">load_config</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">FromCERO</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">_conf</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">_conf</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;self.procedures: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">])</span>

<div class="viewcode-block" id="FromCERO.exec_procedures"><a class="viewcode-back" href="../reference.html#from_cero.FromCERO.exec_procedures">[docs]</a>    <span class="k">def</span> <span class="nf">exec_procedures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cero</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Execute all the procedures of the FromCERO object</span>
<span class="sd">        .</span>
<span class="sd">        :param pandas.DataFrame cero: A CERO to serve as input for the procedures. The argument is not mutated/modified.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">CERO</span><span class="o">.</span><span class="n">is_cero</span><span class="p">(</span><span class="n">cero</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">empty_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">CERO</span><span class="o">.</span><span class="n">rename_index_values</span><span class="p">(</span><span class="n">cero</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;map&quot;</span><span class="p">,</span> <span class="p">{}))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">output_procedures</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">procedure</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">]:</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">procedure</span><span class="o">.</span><span class="n">exec_ops</span><span class="p">(</span><span class="n">cero</span><span class="p">)</span>
                <span class="c1"># if ret is not None, should be dict with key: procedure[&quot;name&quot;], value: resultant CERO</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">e</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; Error in procedure &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">procedure</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">output_procedures</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">]:</span> <span class="c1"># If empty list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output_procedures</span><span class="p">[</span><span class="s2">&quot;default_output&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cero</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="ow">not</span> <span class="n">procedure</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;file&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">procedure</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">]]):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;It has been detected that not all procedures direct output to file. Therefore some output will go to </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">]</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_procedures</span> <span class="o">!=</span> <span class="p">{}:</span>
            <span class="n">file_ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">])[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">file_ext</span> <span class="ow">in</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">sup_output_types</span><span class="p">:</span>
                <span class="n">out_df</span> <span class="o">=</span> <span class="n">CERO</span><span class="o">.</span><span class="n">combine_ceros</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">output_procedures</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
                <span class="n">FromCERO</span><span class="o">.</span><span class="n">dataframe_out</span><span class="p">(</span><span class="n">out_df</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">],</span> <span class="n">output_type</span><span class="o">=</span><span class="n">file_ext</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">file_ext</span> <span class="ow">in</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_Procedure</span><span class="o">.</span><span class="n">sup_output_types</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This data type is not supported for general export, because it probably has a more than 2 dimensions - export using &#39;procedures&#39; instead.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unsupported data type detected for general export.&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">get_filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">get_relpath</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">],</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;get_filepath() returns: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_relpath</span><span class="p">(</span><span class="n">base_dir</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_dir</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_load_set</span><span class="p">(</span><span class="nb">set</span><span class="p">:</span> <span class="s2">&quot;List[str]&quot;</span><span class="p">):</span>

        <span class="nb">set</span> <span class="o">=</span> <span class="n">_Identifier</span><span class="o">.</span><span class="n">get_all_idents</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="nb">set</span><span class="p">),</span> <span class="nb">list</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Each set must be provided as a list, not type &#39;</span><span class="si">%s</span><span class="s2">&#39; for object </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="nb">type</span><span class="p">(</span><span class="nb">set</span><span class="p">),</span> <span class="nb">set</span><span class="p">)</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">set</span>


<div class="viewcode-block" id="FromCERO.load_config"><a class="viewcode-back" href="../reference.html#from_cero.FromCERO.load_config">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">load_config</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads configuration of FromCERO. If conf is a `str`, this is interpreted as a file (in YAML format) containing a configuration dictionary (relative to the current working directory). Otherwise conf must be a dictionary.</span>

<span class="sd">        :param &#39;Union[str,dict]&#39; conf:</span>
<span class="sd">        :return dict:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">_conf</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;operations&quot;</span><span class="p">:</span> <span class="p">[],</span>
                 <span class="s2">&quot;file&quot;</span><span class="p">:</span> <span class="s2">&quot;output.csv&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;sets&quot;</span><span class="p">:</span> <span class="p">{},</span>
                 <span class="s2">&quot;map&quot;</span><span class="p">:</span> <span class="p">{},</span>
                 <span class="s2">&quot;ref_dir&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="c1"># Type: str</span>
                 <span class="s2">&quot;procedures&quot;</span><span class="p">:</span> <span class="p">[],</span>
                 <span class="s2">&quot;libfuncs&quot;</span><span class="p">:</span> <span class="p">[]}</span>  <span class="c1"># Defaults</span>

        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">_conf</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">conf</span><span class="p">))</span>
            <span class="n">conf</span> <span class="o">=</span> <span class="n">read_yaml</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span> <span class="c1"># Load configuration file</span>

            <span class="k">if</span> <span class="n">conf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># Loading an empty file</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Attempted to load an empty file.&quot;</span><span class="p">)</span>

        <span class="n">_conf</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>

        <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">get_relpath</span><span class="p">(</span><span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">],</span> <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">])</span>

        <span class="n">system_libfuncs</span> <span class="o">=</span> <span class="n">concero</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">find_file</span><span class="p">(</span><span class="s2">&quot;libfuncs.py&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">system_libfuncs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;libfuncs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">system_libfuncs</span><span class="p">)</span>

        <span class="c1"># Load sets</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_conf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sets&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="c1"># If provided as a string, assume to be a file relative to ref_dir</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">],</span> <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>
                <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_yaml</span><span class="p">(</span><span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>

            <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_load_set</span><span class="p">(</span><span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;sets&quot;</span><span class="p">][</span><span class="n">k</span><span class="p">])</span>

        <span class="n">file_ext</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">])[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">file_ext</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;file&#39; must be specified with an extension.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">procedure</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">]):</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">procedure</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">str</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">procedure</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;yaml&quot;</span><span class="p">,</span> <span class="s2">&quot;yml&quot;</span><span class="p">]:</span>
                <span class="c1"># If given a YAML filename, interpret as link to YAML dict</span>
                <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">get_relpath</span><span class="p">(</span><span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;ref_dir&quot;</span><span class="p">],</span> <span class="n">procedure</span><span class="p">)</span>
                <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">read_yaml</span><span class="p">(</span><span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">])</span>

            <span class="n">parent</span> <span class="o">=</span> <span class="n">_conf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;procedures&quot;</span><span class="p">)</span>  <span class="c1"># Avoid recursive inheritance loop</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;file&quot;</span><span class="p">)</span>  <span class="c1"># Procedure should not output to file unless a file is specified</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
                <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;Unnamed_proc_</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">idx</span>

            <span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_Procedure</span><span class="o">.</span><span class="n">from_obj</span><span class="p">(</span><span class="n">_conf</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">][</span><span class="n">idx</span><span class="p">],</span> <span class="n">parent</span><span class="o">=</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_conf</span></div>

<div class="viewcode-block" id="FromCERO.is_valid"><a class="viewcode-back" href="../reference.html#from_cero.FromCERO.is_valid">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="n">conf</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs static checks on ``conf`` to verify if ``conf`` can be converted to a FromCERO object.</span>

<span class="sd">        Checks include:</span>
<span class="sd">            * Valid type.</span>
<span class="sd">            * Valid procedures.</span>
<span class="sd">            * If ``file`` given, that the user has write permissions in that directory.</span>

<span class="sd">        :param dict conf: The object to check the validity of.</span>
<span class="sd">        :param bool raise_exception: If `True` (the default) then an exception will be raised on failure. Otherwise an error message will be printed to stdout and `False` returned.</span>
<span class="sd">        :return bool: `True` if ``conf`` passes all static checks.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">conf</span><span class="p">),</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Configuration is of type </span><span class="si">%s</span><span class="s2"> (that is, not a dictionary).&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">procedure</span><span class="p">),</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_Procedure</span><span class="p">)</span><span class="k">for</span> <span class="n">procedure</span> <span class="ow">in</span> <span class="n">conf</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">]]):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Not all procedures are FromCERO._Procedure objects.&quot;</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="s2">&quot;file&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">procedure</span> <span class="k">for</span> <span class="n">procedure</span> <span class="ow">in</span> <span class="n">conf</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">]]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_check_permissions</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">],</span> <span class="n">raise_exception</span><span class="o">=</span><span class="n">raise_exception</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">for</span> <span class="n">procedure</span> <span class="ow">in</span> <span class="n">conf</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">_Procedure</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">procedure</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="n">raise_exception</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="FromCERO.run_checks"><a class="viewcode-back" href="../reference.html#from_cero.FromCERO.run_checks">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">run_checks</span><span class="p">(</span><span class="n">conf</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">cero</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs runtime checks on ``conf``, given ``cero``.</span>

<span class="sd">        :param dict conf: The object to check the validity of.</span>
<span class="sd">        :param bool raise_exception: If `True` (the default) then an exception will be raised on failure. Otherwise an error message will be printed to stdout and `False` returned.</span>
<span class="sd">        :return bool: `True` if ``conf`` passes all runtime checks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">procedure</span> <span class="ow">in</span> <span class="n">conf</span><span class="p">[</span><span class="s2">&quot;procedures&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">procedure</span><span class="o">.</span><span class="n">run_checks</span><span class="p">(</span><span class="n">cero</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="n">raise_exception</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="kc">True</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">check_config</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">runtime</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">conf</span> <span class="o">=</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">load_config</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">runtime</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">run_checks</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="n">raise_exception</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FromCERO</span><span class="o">.</span><span class="n">is_valid</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="n">raise_exception</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_permissions</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">raise_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">test_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">file</span><span class="p">),</span> <span class="s2">&quot;.write_test.tmp&quot;</span><span class="p">)</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">test_file</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">PermissionError</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;User &#39;</span><span class="si">%s</span><span class="s2">&#39; does not have write permissions in directory &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">getpass</span><span class="o">.</span><span class="n">getuser</span><span class="p">(),</span>
                                                                                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">file</span><span class="p">[</span><span class="s2">&quot;file&quot;</span><span class="p">]))</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">raise_exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">PermissionError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">fp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">test_file</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">dataframe_out</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">output_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;CERO is empty - no data to export.&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">output_file</span> <span class="o">=</span> <span class="n">output_file</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">output_type</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">output_file</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="n">output_file</span>
        <span class="k">if</span> <span class="n">output_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;npy&#39;</span><span class="p">]:</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_numpy_out</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">output_file</span><span class="p">,</span> <span class="n">output_kwargs</span><span class="o">=</span><span class="n">output_kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">output_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;png&#39;</span><span class="p">,</span> <span class="s1">&#39;pdf&#39;</span><span class="p">,</span> <span class="s1">&#39;ps&#39;</span><span class="p">,</span> <span class="s1">&#39;eps&#39;</span><span class="p">,</span> <span class="s1">&#39;svg&#39;</span><span class="p">]:</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_plot</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">output_file</span><span class="p">,</span> <span class="n">output_kwargs</span><span class="o">=</span><span class="n">output_kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">output_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;csv&quot;</span><span class="p">]:</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_csv_out</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">output_file</span><span class="p">,</span> <span class="n">output_kwargs</span><span class="o">=</span><span class="n">output_kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">output_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;xlsx&quot;</span><span class="p">,</span> <span class="s2">&quot;excel&quot;</span><span class="p">]:</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_xlsx_out</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">output_file</span><span class="p">,</span> <span class="n">output_kwargs</span><span class="o">=</span><span class="n">output_kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">output_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;gdx&quot;</span><span class="p">}:</span>
            <span class="n">FromCERO</span><span class="o">.</span><span class="n">_gdx_out</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">output_file</span><span class="p">,</span> <span class="n">output_kwargs</span><span class="o">=</span><span class="n">output_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Output files of this type cannot be created from dataframes. It will be necessary &quot;</span> <span class="o">+</span> \
                            <span class="s2">&quot;to create your own output function in concero.libfuncs and call it as an operation.&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_csv_out</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">output_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;date_format&quot;</span><span class="p">:</span> <span class="s2">&quot;%Y&quot;</span><span class="p">}</span>

        <span class="c1"># Update with given arguments</span>
        <span class="k">if</span> <span class="n">output_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">output_kwargs</span><span class="p">)</span>
        <span class="n">output_kwargs</span> <span class="o">=</span> <span class="n">defaults</span>

        <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="o">**</span><span class="n">output_kwargs</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_xlsx_out</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">output_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="n">defaults</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;columns&quot;</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%Y&quot;</span><span class="p">),</span>
                    <span class="s2">&quot;sheet_name&quot;</span><span class="p">:</span> <span class="s2">&quot;CERO&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;tupleize_cols&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>

        <span class="c1"># Update with given arguments</span>
        <span class="k">if</span> <span class="n">output_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">defaults</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">output_kwargs</span><span class="p">)</span>
        <span class="n">output_kwargs</span> <span class="o">=</span> <span class="n">defaults</span>

        <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">tupleize_cols</span><span class="o">=</span><span class="n">defaults</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;tupleize_cols&quot;</span><span class="p">))</span> <span class="c1"># Convert to multi-index for nice formatting</span>

        <span class="n">df</span><span class="o">.</span><span class="n">to_excel</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="o">**</span><span class="n">output_kwargs</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_numpy_out</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">output_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">output_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="o">**</span><span class="n">output_kwargs</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_gdx_out</span><span class="p">(</span><span class="n">df</span><span class="p">:</span> <span class="s1">&#39;Dict[str, pd.DataFrame]&#39;</span><span class="p">,</span> <span class="n">output_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Note: output_kwargs is in signature for compatibility with other output functions. output_kwargs could be \</span>
<span class="sd">        implemented but is not currently.</span>

<span class="sd">        :param df:</span>
<span class="sd">        :param output_file:</span>
<span class="sd">        :param output_kwargs:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">output_file</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s1">&#39;.gdx&#39;</span><span class="p">:</span>
            <span class="n">output_file</span> <span class="o">+=</span> <span class="s1">&#39;.gdx&#39;</span> <span class="c1"># Add file extension if necessary</span>

        <span class="c1"># out_obj = copy.deepcopy(out_obj)</span>

        <span class="c1"># for out_ser, out_df in df.items():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span><span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AssertionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="n">libfuncs_wrappers</span><span class="o">.</span><span class="n">_rename</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;Value&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;Year&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y&#39;</span><span class="p">)</span> <span class="c1"># Convert datetimes to strings</span>
        <span class="n">df</span><span class="p">[</span><span class="n">out_ser</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;Year&#39;</span><span class="p">,</span> <span class="s1">&#39;Value&#39;</span><span class="p">]]</span> <span class="c1"># Reorder</span>


        <span class="k">with</span> <span class="n">gdxpds</span><span class="o">.</span><span class="n">gdx</span><span class="o">.</span><span class="n">GdxFile</span><span class="p">()</span> <span class="k">as</span> <span class="n">gdxf</span><span class="p">:</span>

            <span class="c1"># for out_ser, out_df in df.items():</span>
            <span class="c1"># Create a new set with one dimension</span>
            <span class="n">gdxf</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gdxpds</span><span class="o">.</span><span class="n">gdx</span><span class="o">.</span><span class="n">GdxSymbol</span><span class="p">(</span><span class="n">out_ser</span><span class="p">,</span> <span class="n">gdxpds</span><span class="o">.</span><span class="n">gdx</span><span class="o">.</span><span class="n">GamsDataType</span><span class="o">.</span><span class="n">Parameter</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Index&#39;</span><span class="p">]))</span>
            <span class="n">gdxf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dataframe</span> <span class="o">=</span> <span class="n">df</span>
            <span class="n">gdxf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">output_file</span><span class="p">)</span> <span class="c1"># Create a new parameter with one dimension</span>

        <span class="n">FromCERO</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Exported to file </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s2"> successfully.&quot;</span> <span class="o">%</span> <span class="n">output_file</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_plot</span><span class="p">(</span><span class="n">out_obj</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">output_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">output_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">output_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">plotformat</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">output_file</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">libfuncs</span><span class="o">.</span><span class="n">plotdf</span><span class="p">(</span><span class="n">out_obj</span><span class="p">,</span> <span class="n">figurepath</span><span class="o">=</span><span class="n">output_file</span><span class="p">,</span> <span class="n">plotformat</span><span class="o">=</span><span class="n">plotformat</span><span class="p">,</span> <span class="o">**</span><span class="n">output_kwargs</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, CSIRO.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
    </div>

    

    
  </body>
</html>